#include <ros/ros.h>
#include <string.h>
#include <stdlib.h>
#include <chrono>
#include <thread>

#include <mavros_msgs/State.h>

#include "uas_control.h"


ros::Subscriber currStateSub;
mavros_msgs::State currState;
int stateQueueSize = 5;


void stateCallback(const mavros_msgs::State::ConstPtr& msg){
    currState = *msg;
}

void sleep_for(int seconds) {
    // Wraps long function for lazy programers
    std::this_thread::sleep_for(std::chrono::seconds(seconds));
}

int main(int argc, char** argv){

    // Initialization//
    ros::init(argc, argv, "xipiterUAV");
    ros::NodeHandle n;
    uasControl myUAS = uasControl(n);

    // Subcriptions
    currStateSub = n.subscribe<mavros_msgs::State>("mavros/state", stateQueueSize, stateCallback);

    // Vehicle Setup //
    // Configure connection to FCU
    ros::Rate rate(10); //node operating rate of 10Hz. (must be >2Hz to support custom mode operation--otherwise drops out to previous mode)
    while(ros::ok() && !currState.connected){
        ros::spinOnce(); //call callbacks to check for autopilot connection
        rate.sleep(); //wait a cycle
    }
    ROS_INFO("Connected to FCU.\n");

    sleep_for(2);

    myUAS.wpClear();

    sleep_for(1);

    ROS_INFO("Recived %d waypoints", myUAS.wpPull());

    sleep_for(10);

    // Push waypoints (generated by Grayson)
    myUAS.wpPushTest();

    ROS_INFO("Recived %d waypoints", myUAS.wpPull());

    sleep_for(2);

    // Arm vehicle
    bool armed = false;
    do {
        sleep_for(1);
        armed = (bool)myUAS.setArming(true);
        ros::spinOnce(); //check callback for state change (i.e. is now armed?)
    } while (!armed);

    sleep_for(2);

    myUAS.setMode("13");

    // Main Loop //
    // Curently ensures the mode is auto

    sleep_for(5);

    myUAS.setMode("AUTO");

    while (ros::ok()){
        
        sleep_for(3);
        ros::spinOnce();

    }


    return 0;
}

